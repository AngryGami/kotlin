/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.gradle.plugins.tools

import org.gradle.api.DefaultTask
import org.gradle.api.file.FileCollection
import org.gradle.work.ChangeType
import org.gradle.work.Incremental
import org.gradle.work.InputChanges
import org.jetbrains.org.objectweb.asm.ClassReader
import org.jetbrains.org.objectweb.asm.ClassVisitor
import org.jetbrains.org.objectweb.asm.Label
import org.jetbrains.org.objectweb.asm.MethodVisitor
import org.jetbrains.org.objectweb.asm.Opcodes
import java.util.TreeSet
import java.util.TreeMap
import org.gradle.api.GradleException
import org.gradle.api.provider.ListProperty
import org.gradle.api.tasks.*

/**
 * Calling File.getCanonicalFile and File.getCanonicalPath strongly affects performance. For example, see KT-54579.
 */
@CacheableTask
abstract class InspectForForbidenAPIUsage: DefaultTask() {

    @get:Input
    abstract val forbiddenMethods: ListProperty<String>

    @get:Input
    abstract val ignoreClasses: ListProperty<String>

    init {
        outputs.upToDateWhen { true }
    }

    @Incremental
    @get:Classpath
    var validationClasspath: FileCollection = project.objects.fileCollection()

    @TaskAction
    fun execute(inputChanges: InputChanges) {
        val forbidenMethods = forbiddenMethods.get().map {
            val separatorIndex = it.lastIndexOf('.')
            if (separatorIndex <= 0 || it.endsWith(".")) {
                throw GradleException("Could not identify class name method name in string \"$it\". Valid example: \"java.io.File.getCanonicalFile\"")
            }
            MethodReference(it.substring(0, separatorIndex), it.substring(separatorIndex + 1))
        }

        val changedFiles =
        inputChanges.getFileChanges(validationClasspath)
            .filter { it.changeType == ChangeType.ADDED || it.changeType == ChangeType.MODIFIED }
            .filter { it.file.name.endsWith(".class", true) }
            .map { it.file }

        logger.info("Inspecting classpath for forbiden methods.\n" +
                            "Forbiden methods: ${forbidenMethods}\n" +
                            "Changed classes: $changedFiles")

        val classVisitor = SearchingClassVisitor(forbidenMethods)

        changedFiles.forEach { file ->
            logger.debug("Reading class ${file.absolutePath}")
            val reader = ClassReader(file.readBytes())
            logger.debug("Parsing class ${file.absolutePath}")
            reader.accept(classVisitor, 0)
        }

        if (classVisitor.getCalls().isNotEmpty()) {
            val (warnings, errors) = classVisitor.getCalls().keys.partition { ignoreClasses.get().contains(it.className.replace('/', '.')) }
            if (warnings.isNotEmpty()) {
                logger.info("The following classes invoke forbiden methods, but these problems are suppressed:")
                warnings.forEach { logger.info("$it contains invocation of ${classVisitor.getCalls().get(it)?.joinToString(", ")}")}
            }
            if (errors.isNotEmpty()) {
                logger.error("The following classes invoke forbiden methods:")
                errors.forEach { logger.error("$it contains invocation of ${classVisitor.getCalls().get(it)?.joinToString(", ")}")}

                throw GradleException("Generated bytecode contains invocations of unrecommended methods. See log for details.")
            }
        }
    }
}



data class CallSite(val className: String, val methodName: String, val source: String, val line: Int): Comparable<CallSite> {
    override fun compareTo(other: CallSite): Int {
        return toString().compareTo(other.toString())
    }

    override fun toString()  = "${className.replace('/', '.')}.$methodName ($source:$line )"
}

data class MethodReference(val className: String, val methodName: String): Comparable<MethodReference> {

    override fun compareTo(other: MethodReference) = toString().compareTo(other.toString())

    override fun toString(): String = "$className.$methodName"
}

class SearchState {
    var className: String = ""
    var methodName: String = ""
    var sourceFile: String = ""
    var lineNumber: Int = 0
}

const val API_VERSION = Opcodes.ASM5

class SearchingClassVisitor(methods: Collection<MethodReference>) : ClassVisitor(API_VERSION) {

    class SearchingMethodVisitor(private val searchState: SearchState, private val methodsToFind: Collection<MethodReference>) : MethodVisitor(API_VERSION) {

        val calls = TreeMap<CallSite, MutableSet<MethodReference>>()

        override fun visitMethodInsn(opcode: Int, owner: String, name: String, desc: String, itf: Boolean) {
            val methodReference = MethodReference(owner.replace('/', '.'), name)
            if (methodsToFind.contains(methodReference)) {
                calls.getOrPut(CallSite(searchState.className, searchState.methodName, searchState.sourceFile, searchState.lineNumber)) {
                    TreeSet()
                }.add(methodReference)
            }
        }

        override fun visitLineNumber(line: Int, start: Label) {
            searchState.lineNumber = line
        }
    }

    private val searchState = SearchState()
    private val methodVisitor = SearchingMethodVisitor(searchState, methods)

    override fun visit(version: Int, access: Int, name: String, signature: String?, superName: String, interfaces: Array<String>) {
        searchState.className = name
    }

    override fun visitSource(source: String, debug: String?) {
        searchState.sourceFile = source
    }

    override fun visitMethod(
        access: Int, name: String,
        desc: String, signature: String?,
        exceptions: Array<String>?
    ): MethodVisitor {
        searchState.methodName = name
        return methodVisitor
    }

    fun getCalls() = methodVisitor.calls
}
